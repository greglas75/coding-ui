-- Migration: Update codes table for AI codeframe support
-- Description: Adds fields to support hierarchical AI-generated codes
-- Dependencies: Requires previous codeframe migrations

-- ============================================================================
-- Add new columns to codes table
-- ============================================================================

-- Hierarchical structure support
ALTER TABLE codes
ADD COLUMN IF NOT EXISTS parent_code_id INTEGER REFERENCES codes(id) ON DELETE SET NULL;

ALTER TABLE codes
ADD COLUMN IF NOT EXISTS level INTEGER DEFAULT 0;

-- AI generation tracking
ALTER TABLE codes
ADD COLUMN IF NOT EXISTS is_auto_generated BOOLEAN DEFAULT FALSE;

ALTER TABLE codes
ADD COLUMN IF NOT EXISTS generation_id UUID REFERENCES codeframe_generations(id) ON DELETE SET NULL;

ALTER TABLE codes
ADD COLUMN IF NOT EXISTS confidence VARCHAR(20);

-- Translation tracking (if codes auto-translated)
ALTER TABLE codes
ADD COLUMN IF NOT EXISTS original_name TEXT;

ALTER TABLE codes
ADD COLUMN IF NOT EXISTS original_language VARCHAR(10);

-- Additional metadata
ALTER TABLE codes
ADD COLUMN IF NOT EXISTS description TEXT;

ALTER TABLE codes
ADD COLUMN IF NOT EXISTS example_texts JSONB;

-- ============================================================================
-- Add indexes for new columns
-- ============================================================================

CREATE INDEX IF NOT EXISTS idx_codes_parent_code ON codes(parent_code_id);
CREATE INDEX IF NOT EXISTS idx_codes_generation ON codes(generation_id);
CREATE INDEX IF NOT EXISTS idx_codes_auto_generated ON codes(is_auto_generated);
CREATE INDEX IF NOT EXISTS idx_codes_level ON codes(level);

-- ============================================================================
-- Add constraints
-- ============================================================================

-- Ensure confidence values are valid
ALTER TABLE codes
ADD CONSTRAINT chk_codes_confidence
CHECK (confidence IS NULL OR confidence IN ('high', 'medium', 'low'));

-- Ensure level is non-negative
ALTER TABLE codes
ADD CONSTRAINT chk_codes_level_positive
CHECK (level >= 0);

-- Ensure parent_code_id doesn't create cycles (self-reference not allowed)
ALTER TABLE codes
ADD CONSTRAINT chk_codes_no_self_reference
CHECK (parent_code_id IS NULL OR parent_code_id != id);

-- ============================================================================
-- Add comments for documentation
-- ============================================================================

COMMENT ON COLUMN codes.parent_code_id IS
'Parent code ID for hierarchical structure (NULL for top-level codes)';

COMMENT ON COLUMN codes.level IS
'Depth in hierarchy: 0=top-level, 1=sub-code, 2=sub-sub-code, etc.';

COMMENT ON COLUMN codes.is_auto_generated IS
'True if code was generated by AI, false if manually created';

COMMENT ON COLUMN codes.generation_id IS
'Reference to codeframe generation that created this code';

COMMENT ON COLUMN codes.confidence IS
'AI confidence in this code: high, medium, or low';

COMMENT ON COLUMN codes.original_name IS
'Original code name before translation (if applicable)';

COMMENT ON COLUMN codes.original_language IS
'Language of original name (ISO code)';

COMMENT ON COLUMN codes.description IS
'Detailed description of what this code represents';

COMMENT ON COLUMN codes.example_texts IS
'JSON array of example texts from Claude: [{"id": "1", "text": "example"}]';

-- ============================================================================
-- Create helper functions
-- ============================================================================

-- Function to get all child codes recursively
CREATE OR REPLACE FUNCTION get_child_codes(parent_id_param INTEGER)
RETURNS TABLE (
    code_id INTEGER,
    code_name VARCHAR(255),
    code_level INTEGER,
    path INTEGER[]
) AS $$
WITH RECURSIVE code_tree AS (
    -- Base case: direct children
    SELECT
        id,
        name,
        level,
        ARRAY[id] as path
    FROM codes
    WHERE parent_code_id = parent_id_param

    UNION ALL

    -- Recursive case: children of children
    SELECT
        c.id,
        c.name,
        c.level,
        ct.path || c.id
    FROM codes c
    INNER JOIN code_tree ct ON c.parent_code_id = ct.code_id
)
SELECT
    code_id,
    code_name,
    code_level,
    path
FROM code_tree
ORDER BY path;
$$ LANGUAGE sql;

COMMENT ON FUNCTION get_child_codes IS
'Recursively get all child codes of a given parent code';

-- Function to get code path from root to leaf
CREATE OR REPLACE FUNCTION get_code_path(code_id_param INTEGER)
RETURNS TABLE (
    code_id INTEGER,
    code_name VARCHAR(255),
    code_level INTEGER
) AS $$
WITH RECURSIVE code_path AS (
    -- Base case: the target code
    SELECT
        id,
        name,
        level,
        parent_code_id
    FROM codes
    WHERE id = code_id_param

    UNION ALL

    -- Recursive case: parent codes
    SELECT
        c.id,
        c.name,
        c.level,
        c.parent_code_id
    FROM codes c
    INNER JOIN code_path cp ON c.id = cp.parent_code_id
)
SELECT
    code_id,
    code_name,
    code_level
FROM code_path
ORDER BY code_level;
$$ LANGUAGE sql;

COMMENT ON FUNCTION get_code_path IS
'Get the full path from root to a specific code';

-- Function to validate hierarchy consistency
CREATE OR REPLACE FUNCTION validate_code_hierarchy()
RETURNS TABLE (
    issue_type VARCHAR(50),
    code_id INTEGER,
    message TEXT
) AS $$
BEGIN
    -- Check for orphaned codes (parent doesn't exist)
    RETURN QUERY
    SELECT
        'orphaned_code'::VARCHAR(50),
        c.id,
        'Parent code ' || c.parent_code_id || ' does not exist'
    FROM codes c
    WHERE c.parent_code_id IS NOT NULL
        AND NOT EXISTS (
            SELECT 1 FROM codes WHERE id = c.parent_code_id
        );

    -- Check for level inconsistencies
    RETURN QUERY
    SELECT
        'level_inconsistency'::VARCHAR(50),
        c.id,
        'Level is ' || c.level || ' but parent level is ' || p.level
    FROM codes c
    JOIN codes p ON p.id = c.parent_code_id
    WHERE c.level != p.level + 1;

    -- Check for circular references (should be prevented by constraint)
    RETURN QUERY
    WITH RECURSIVE circular_check AS (
        SELECT
            id,
            parent_code_id,
            ARRAY[id] as path,
            1 as depth
        FROM codes

        UNION ALL

        SELECT
            cc.id,
            c.parent_code_id,
            cc.path || c.parent_code_id,
            cc.depth + 1
        FROM circular_check cc
        JOIN codes c ON c.id = cc.parent_code_id
        WHERE c.parent_code_id = ANY(cc.path)
            AND cc.depth < 10
    )
    SELECT
        'circular_reference'::VARCHAR(50),
        id,
        'Circular reference detected: ' || array_to_string(path, ' -> ')
    FROM circular_check
    WHERE parent_code_id = ANY(path);
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION validate_code_hierarchy IS
'Check for hierarchy consistency issues (orphaned codes, level mismatches, circular refs)';

-- ============================================================================
-- Data migration (if needed)
-- ============================================================================

-- Set level=0 for all existing codes that don't have a parent
UPDATE codes
SET level = 0
WHERE parent_code_id IS NULL AND level IS NULL;

-- Mark all existing codes as manually created (not auto-generated)
UPDATE codes
SET is_auto_generated = FALSE
WHERE is_auto_generated IS NULL;

-- ============================================================================
-- Testing queries (comment out in production)
-- ============================================================================

-- Test hierarchy functions
-- SELECT * FROM get_child_codes(1);
-- SELECT * FROM get_code_path(5);
-- SELECT * FROM validate_code_hierarchy();

-- Verify new columns exist
-- SELECT column_name, data_type, column_default
-- FROM information_schema.columns
-- WHERE table_name = 'codes'
-- AND column_name IN ('parent_code_id', 'level', 'is_auto_generated', 'generation_id');
