"""
Pattern Detection & Multi-Source Aggregation

Analyzes all validation sources and detects patterns:
- Category Error: User text exists but in wrong category
- Ambiguous Descriptor: Term is product descriptor, not brand
- Clear Match: High confidence match from multiple sources
- Unclear: Low confidence, needs manual review

COMPOSITE SCORING FORMULA:
confidence = (
    pinecone_score * 0.40 +
    vision_score * 0.30 +
    kg_score * 0.20 +
    embedding_score * 0.10
) * 100
"""

import logging
from typing import Dict, List, Optional, Any
from validators.multi_source_validator import (
    ValidationResult,
    ValidationType,
    UIAction,
    Candidate,
)

logger = logging.getLogger(__name__)


class PatternDetector:
    """
    Detects patterns from multi-source validation data

    Implements composite scoring and pattern classification
    """

    # Pattern detection thresholds
    CATEGORY_ERROR_THRESHOLD = 0.20  # < 20% confidence suggests category error
    CLEAR_MATCH_THRESHOLD = 0.70  # > 70% confidence is clear match
    AMBIGUOUS_THRESHOLD = 0.50  # 20-50% suggests ambiguity

    def __init__(self):
        logger.info("PatternDetector initialized")

    def detect_pattern(
        self,
        user_text: str,
        category: str,
        pinecone_match: Optional[Any],
        dual_search_results: Any,
        vision_results: Any,
        vision_brands_a: Dict[str, Any],
        vision_brands_b: Dict[str, Any],
        web_brands_a: Dict[str, Any],
        web_brands_b: Dict[str, Any],
        kg_results: Dict[str, Optional[Any]],
        embedding_similarities: Dict[str, float],
        raw_image_urls: Optional[List[Dict[str, str]]] = None,
        raw_web_results: Optional[List[Dict[str, str]]] = None,
        raw_kg_details: Optional[Dict[str, Any]] = None,
    ) -> ValidationResult:
        """
        Analyze all sources and return final validation result

        Args:
            user_text: User's input
            category: Expected category
            pinecone_match: Pinecone search result
            dual_search_results: Google Images dual search
            vision_results: Vision AI analysis
            kg_results: Knowledge Graph verification
            embedding_similarities: Embedding similarity scores

        Returns:
            ValidationResult with detected pattern
        """
        logger.info(f"üîç Pattern Detection: Analyzing all sources...")

        # PATTERN 0: Category Validated by Product Type Filtering
        category_validated = self._detect_category_validated(
            user_text,
            category,
            vision_brands_a,
            vision_brands_b,
            web_brands_a,
            web_brands_b,
            vision_results,
            kg_results,
            embedding_similarities,
        )
        if category_validated:
            # Add raw data
            category_validated.image_urls = raw_image_urls
            category_validated.web_results = raw_web_results
            category_validated.kg_details = raw_kg_details
            return category_validated

        # PATTERN 1: Category Error
        category_error = self._detect_category_error(
            user_text,
            category,
            dual_search_results,
            kg_results,
            embedding_similarities,
        )
        if category_error:
            # Add raw data
            category_error.image_urls = raw_image_urls
            category_error.web_results = raw_web_results
            category_error.kg_details = raw_kg_details
            return category_error

        # PATTERN 2: Ambiguous Descriptor
        ambiguous = self._detect_ambiguous_descriptor(
            user_text,
            category,
            vision_results,
            kg_results,
            embedding_similarities,
        )
        if ambiguous:
            # Add raw data
            ambiguous.image_urls = raw_image_urls
            ambiguous.web_results = raw_web_results
            ambiguous.kg_details = raw_kg_details
            return ambiguous

        # PATTERN 3: Clear Match
        clear_match = self._detect_clear_match(
            category,
            vision_results,
            kg_results,
            embedding_similarities,
        )
        if clear_match:
            # Add raw data
            clear_match.image_urls = raw_image_urls
            clear_match.web_results = raw_web_results
            clear_match.kg_details = raw_kg_details
            return clear_match

        # PATTERN 4: Unclear - needs manual review
        unclear = self._create_unclear_result(
            category=category,
            pinecone_match=pinecone_match,
            dual_search_results=dual_search_results,
            vision_results=vision_results,
            vision_brands_a=vision_brands_a,
            vision_brands_b=vision_brands_b,
            web_brands_a=web_brands_a,
            web_brands_b=web_brands_b,
            kg_results=kg_results,
            embedding_similarities=embedding_similarities,
        )
        # Add raw data even for unclear results
        unclear.image_urls = raw_image_urls
        unclear.web_results = raw_web_results
        unclear.kg_details = raw_kg_details
        return unclear

    def _detect_category_validated(
        self,
        user_text: str,
        category: str,
        vision_brands_a: Dict[str, Any],
        vision_brands_b: Dict[str, Any],
        web_brands_a: Dict[str, Any],
        web_brands_b: Dict[str, Any],
        vision_results: Any,
        kg_results: Dict[str, Optional[Any]],
        embedding_similarities: Dict[str, float],
    ) -> Optional[ValidationResult]:
        """
        PATTERN 0: Category Validated by Product Type Filtering

        Triggers:
        - Search B (with category) has high correct product type matches (>= 5)
        - Search A (without category) has significant mismatches (>= 3)
        - This validates that the category filter is working correctly!
        - Now uses BOTH Vision AI AND Web Search AI for validation

        Example:
            User: "Oral-B" + Category: "Toothpaste"
            Vision AI Search A: 3 toothpaste + 3 electric toothbrushes (50% wrong type!)
            Vision AI Search B: 6 toothpaste (100% correct type!)
            Web AI Search B: 8 toothpaste (100% correct type!)
            ‚Üí Category is validated! Brand exists in correct product type.
        """
        # Count from both Vision AI and Web Search AI
        vision_correct_a = vision_brands_a.get("correct_matches", 0)
        vision_correct_b = vision_brands_b.get("correct_matches", 0)
        vision_mismatched_a = vision_brands_a.get("mismatched_count", 0)
        vision_mismatched_b = vision_brands_b.get("mismatched_count", 0)

        web_correct_a = web_brands_a.get("correct_matches", 0)
        web_correct_b = web_brands_b.get("correct_matches", 0)
        web_mismatched_a = web_brands_a.get("mismatched_count", 0)
        web_mismatched_b = web_brands_b.get("mismatched_count", 0)

        # Combined totals
        total_correct_b = vision_correct_b + web_correct_b
        total_mismatched_a = vision_mismatched_a + web_mismatched_a

        # Check if Search B has strong correct matches and Search A has mismatches
        # LOWER THRESHOLD: 3 correct (was 5), 2 mismatched (was 3) - more lenient
        if total_correct_b >= 3 and total_mismatched_a >= 2:
            # This is a strong signal that category filtering is working!
            # Search without category shows wrong product types
            # Search with category shows correct product types

            # Get the dominant brand from correctly typed products
            # Combine both Vision and Web brands
            vision_brands = vision_brands_b.get("brands", {})
            web_brands = web_brands_b.get("brands", {})

            # Merge brand counts from both sources
            combined_brands = {}
            for brand, data in vision_brands.items():
                combined_brands[brand] = data["count"]
            for brand, data in web_brands.items():
                combined_brands[brand] = combined_brands.get(brand, 0) + data["count"]

            if not combined_brands:
                return None

            # Find brand with highest combined count
            brand_name = max(combined_brands.items(), key=lambda x: x[1])[0]

            # Get data from vision if available, otherwise web
            brand_data = vision_brands.get(brand_name) or web_brands.get(brand_name)

            # Check if KG verifies this brand
            kg_result = kg_results.get(brand_name)
            kg_verified = kg_result and kg_result.verified and kg_result.matches_user_category

            # Get embedding similarity
            embedding_sim = embedding_similarities.get(brand_name, 0.0)

            # Calculate confidence with KG BOOST
            # High confidence because multi-source category filtering works
            base_confidence = 88  # Increased from 85 because we have 2 sources

            # KG Verification adds significant boost
            kg_bonus = 0
            if kg_verified:
                kg_type = kg_result.entity_type if hasattr(kg_result, 'entity_type') else None
                if kg_type == "Brand":
                    kg_bonus = 15  # Strong signal for verified brand
                elif kg_type in ["Product", "Company"]:
                    kg_bonus = 10  # Medium signal
                else:
                    kg_bonus = 5   # Weak signal

            embedding_bonus = int(embedding_sim * 10)
            confidence = min(98, base_confidence + kg_bonus + embedding_bonus)

            # Get mismatched product types for reasoning
            mismatched_types = set()
            for mismatch in vision_brands_a.get("mismatched_products", []):
                mismatched_types.add(mismatch["detected_type"])
            for mismatch in web_brands_a.get("mismatched_products", []):
                mismatched_types.add(mismatch["detected_type"])

            mismatched_types_str = ", ".join(sorted(mismatched_types)[:3])

            logger.info(
                f"‚úÖ Category Validated (Multi-Source): {brand_name} in {category} | "
                f"Vision B: {vision_correct_b} correct, Web B: {web_correct_b} correct | "
                f"KG verified: {kg_verified} (+{kg_bonus}% boost)"
            )

            # Build reasoning with KG verification
            reasoning = (
                f"Multi-source category validation! "
                f"Vision AI + Web AI detected {total_correct_b} correct {category} products. "
                f"Search without category shows {total_mismatched_a} wrong product types "
                f"({mismatched_types_str}). "
            )

            if kg_verified:
                reasoning += f" Knowledge Graph VERIFIED '{brand_name}' as brand (+{kg_bonus}% confidence boost). "

            reasoning += f"This confirms '{brand_name}' is the correct {category} brand."

            return ValidationResult(
                type=ValidationType.CLEAR_MATCH,
                confidence=confidence,
                reasoning=reasoning,
                ui_action=UIAction.APPROVE if confidence >= 92 else UIAction.MANUAL_REVIEW,
                brand=brand_name,
                expected_category=category,
                sources={
                    "vision_ai_search_a": {
                        "correct_matches": vision_correct_a,
                        "mismatched_count": vision_mismatched_a,
                    },
                    "vision_ai_search_b": {
                        "correct_matches": vision_correct_b,
                        "mismatched_count": vision_mismatched_b,
                        "brands": vision_brands,
                    },
                    "web_search_ai_a": {
                        "correct_matches": web_correct_a,
                        "mismatched_count": web_mismatched_a,
                    },
                    "web_search_ai_b": {
                        "correct_matches": web_correct_b,
                        "mismatched_count": web_mismatched_b,
                        "brands": web_brands,
                    },
                    "multi_source_total": {
                        "total_correct_b": total_correct_b,
                        "total_mismatched_a": total_mismatched_a,
                        "mismatched_types": list(mismatched_types),
                    },
                    "knowledge_graph": {
                        brand_name: {
                            "verified": kg_verified,
                        }
                    },
                    "embeddings": {
                        brand_name: embedding_sim,
                    },
                },
                tier=5,
            )

        return None

    def _detect_category_error(
        self,
        user_text: str,
        category: str,
        dual_search_results: Any,
        kg_results: Dict[str, Optional[Any]],
        embedding_similarities: Dict[str, float],
    ) -> Optional[ValidationResult]:
        """
        PATTERN 1: Category Error

        Triggers:
        - Search B has < 5 results
        - Search A has > 10 results
        - Knowledge Graph: user text exists but in different category
        - Embedding: high similarity (> 0.85) to wrong-category entity

        Example:
            User: "apple" + Category: Toothpaste
            ‚Üí Detected: Apple Inc (technology)
            ‚Üí Suggest: Change category or skip
        """
        # Check search pattern
        if (dual_search_results.search_a_count >= 10 and
            dual_search_results.search_b_count < 5):

            # Check if user_text is verified entity in wrong category
            user_kg = kg_results.get(user_text)
            if user_kg and user_kg.verified and not user_kg.matches_user_category:

                # High embedding similarity confirms it's the wrong-category entity
                max_embedding_sim = max(embedding_similarities.values()) if embedding_similarities else 0

                if max_embedding_sim > 0.85:
                    logger.info(f"üö® Category Error: '{user_text}' is {user_kg.entity_type} ({user_kg.category}), not {category}")

                    confidence = int(max_embedding_sim * 20)  # Low confidence (< 20%)

                    return ValidationResult(
                        type=ValidationType.CATEGORY_ERROR,
                        confidence=confidence,
                        reasoning=f"'{user_text}' exists as {user_kg.entity_type} in {user_kg.category} category, not {category}",
                        ui_action=UIAction.REVIEW_CATEGORY,
                        detected_entity=user_text,
                        detected_category=user_kg.category,
                        expected_category=category,
                        sources=self._build_sources_dict(
                            pinecone_match=None,
                            dual_search_results=dual_search_results,
                            vision_results=None,
                            vision_brands_a=None,
                            vision_brands_b=None,
                            web_brands_a=None,
                            web_brands_b=None,
                            kg_results=kg_results,
                            embedding_similarities=embedding_similarities,
                        ),
                        tier=5,
                    )

        return None

    def _detect_ambiguous_descriptor(
        self,
        user_text: str,
        category: str,
        vision_results: Any,
        kg_results: Dict[str, Optional[Any]],
        embedding_similarities: Dict[str, float],
    ) -> Optional[ValidationResult]:
        """
        PATTERN 2: Ambiguous Descriptor

        Triggers:
        - Vision AI detects 3+ different brands
        - No single brand > 40% frequency
        - User text appears as part of multiple brand names
        - Descriptor keywords: extra, white, whitening, fresh, pro, advanced, complete

        Example:
            User: "ÿßŸÉÿ≥ÿ™ÿ±ÿß" + Category: Toothpaste
            ‚Üí Detected: Sensodyne Extra (33%), Oral-B Extra (33%), Parodontax (17%)
            ‚Üí Ask: "Which brand's Extra product?"
        """
        # Check if vision detected multiple brands
        if (vision_results and
            len(vision_results.brand_frequencies) >= 3 and
            vision_results.dominant_frequency < 0.40):

            # Check if user text is a descriptor keyword
            descriptor_keywords = [
                "extra", "white", "whitening", "fresh", "pro",
                "advanced", "complete", "ultra", "max", "plus"
            ]

            is_descriptor = any(kw in user_text.lower() for kw in descriptor_keywords)

            if is_descriptor or vision_results.pattern == "descriptor":
                logger.info(f"üîÄ Ambiguous Descriptor: '{user_text}' appears in multiple brands")

                # Build candidate list
                candidates = []
                for brand, freq_data in vision_results.brand_frequencies.items():
                    kg_result = kg_results.get(brand)
                    embedding_sim = embedding_similarities.get(brand, 0.0)

                    # Composite score for this candidate
                    vision_score = freq_data["frequency"]
                    kg_score = 1.0 if (kg_result and kg_result.verified) else 0.5
                    composite = (
                        vision_score * 0.50 +
                        kg_score * 0.30 +
                        embedding_sim * 0.20
                    )

                    candidates.append(
                        Candidate(
                            brand=brand,
                            full_name=f"{brand} {user_text}",
                            score=composite,
                            vision_frequency=freq_data["frequency"],
                            kg_verified=bool(kg_result and kg_result.verified),
                            embedding_similarity=embedding_sim,
                            pinecone_match=False,
                        )
                    )

                # Sort by score
                candidates.sort(key=lambda c: c.score, reverse=True)

                # Confidence = highest candidate score * 50 (ambiguous range)
                confidence = int(candidates[0].score * 50) if candidates else 25

                return ValidationResult(
                    type=ValidationType.AMBIGUOUS_DESCRIPTOR,
                    confidence=confidence,
                    reasoning=f"'{user_text}' is a descriptor appearing in multiple brands. User needs to specify which brand.",
                    ui_action=UIAction.ASK_USER_CHOOSE,
                    descriptor=user_text,
                    expected_category=category,
                    candidates=candidates[:5],  # Top 5
                    sources=self._build_sources_dict(
                        pinecone_match=None,
                        dual_search_results=None,
                        vision_results=vision_results,
                        vision_brands_a=None,
                        vision_brands_b=None,
                        web_brands_a=None,
                        web_brands_b=None,
                        kg_results=kg_results,
                        embedding_similarities=embedding_similarities,
                    ),
                    tier=5,
                )

        return None

    def _detect_clear_match(
        self,
        category: str,
        vision_results: Any,
        kg_results: Dict[str, Optional[Any]],
        embedding_similarities: Dict[str, float],
    ) -> Optional[ValidationResult]:
        """
        PATTERN 3: Clear Match

        Triggers:
        - Vision AI: single brand > 50% frequency
        - Knowledge Graph: verified brand in correct category
        - Embedding: moderate-high similarity (> 0.60)

        Example:
            User: "Colgate"
            ‚Üí Vision AI: Colgate 83%
            ‚Üí KG: Verified toothpaste brand
            ‚Üí Embedding: 0.89 similarity
            ‚Üí Result: 90% confidence
        """
        if not vision_results or not vision_results.dominant_brand:
            return None

        # Check vision frequency
        if vision_results.dominant_frequency > 0.50:
            dominant_brand = vision_results.dominant_brand

            # Check KG verification
            kg_result = kg_results.get(dominant_brand)
            kg_verified = kg_result and kg_result.verified and kg_result.matches_user_category

            # Check embedding similarity
            embedding_sim = embedding_similarities.get(dominant_brand, 0.0)

            # Calculate composite confidence with KG BOOST
            vision_score = vision_results.dominant_frequency
            kg_score = 1.0 if kg_verified else 0.5
            base_confidence = int((
                vision_score * 0.50 +
                kg_score * 0.30 +
                embedding_sim * 0.20
            ) * 100)

            # Add KG verification boost
            kg_bonus = 0
            if kg_verified:
                kg_type = kg_result.entity_type if hasattr(kg_result, 'entity_type') else None
                if kg_type == "Brand":
                    kg_bonus = 15  # Strong signal for verified brand
                elif kg_type in ["Product", "Company"]:
                    kg_bonus = 10  # Medium signal
                else:
                    kg_bonus = 5   # Weak signal

            confidence = min(98, base_confidence + kg_bonus)

            if confidence >= 70:
                logger.info(
                    f"‚úÖ Clear Match: {dominant_brand} with {confidence}% confidence "
                    f"(base: {base_confidence}%, KG boost: +{kg_bonus}%)"
                )

                # Build reasoning with KG info
                reasoning = f"High confidence match: {dominant_brand} detected in {vision_results.dominant_frequency:.0%} of images"
                if kg_verified:
                    reasoning += f". Knowledge Graph VERIFIED as brand (+{kg_bonus}% confidence boost)"
                reasoning += ". Multiple sources confirm this brand."

                return ValidationResult(
                    type=ValidationType.CLEAR_MATCH,
                    confidence=confidence,
                    reasoning=reasoning,
                    ui_action=UIAction.APPROVE if confidence >= 85 else UIAction.MANUAL_REVIEW,
                    brand=dominant_brand,
                    expected_category=category,
                    sources=self._build_sources_dict(
                        pinecone_match=None,
                        dual_search_results=None,
                        vision_results=vision_results,
                        vision_brands_a=None,
                        vision_brands_b=None,
                        web_brands_a=None,
                        web_brands_b=None,
                        kg_results=kg_results,
                        embedding_similarities=embedding_similarities,
                    ),
                    tier=5,
                )

        return None

    def _create_unclear_result(
        self,
        category: str,
        pinecone_match: Optional[Any],
        dual_search_results: Optional[Any],
        vision_results: Optional[Any],
        vision_brands_a: Dict[str, Any],
        vision_brands_b: Dict[str, Any],
        web_brands_a: Dict[str, Any],
        web_brands_b: Dict[str, Any],
        kg_results: Dict[str, Optional[Any]],
        embedding_similarities: Dict[str, float],
    ) -> ValidationResult:
        """
        PATTERN 4: Unclear

        Triggers:
        - Low confidence from all sources
        - Conflicting information
        - Insufficient data

        IMPORTANT: Still includes all sources data for UI display!
        """
        logger.info(f"‚ùì Unclear: Insufficient data for confident determination")

        return ValidationResult(
            type=ValidationType.UNCLEAR,
            confidence=0,
            reasoning="Insufficient data from all sources to make confident determination",
            ui_action=UIAction.MANUAL_REVIEW,
            expected_category=category,
            sources=self._build_sources_dict(
                pinecone_match=pinecone_match,
                dual_search_results=dual_search_results,
                vision_results=vision_results,
                vision_brands_a=vision_brands_a,
                vision_brands_b=vision_brands_b,
                web_brands_a=web_brands_a,
                web_brands_b=web_brands_b,
                kg_results=kg_results,
                embedding_similarities=embedding_similarities,
            ),
            tier=5,
        )

    def _build_sources_dict(
        self,
        pinecone_match: Optional[Any],
        dual_search_results: Optional[Any],
        vision_results: Optional[Any],
        vision_brands_a: Optional[Dict[str, Any]],
        vision_brands_b: Optional[Dict[str, Any]],
        web_brands_a: Optional[Dict[str, Any]],
        web_brands_b: Optional[Dict[str, Any]],
        kg_results: Optional[Dict[str, Optional[Any]]],
        embedding_similarities: Optional[Dict[str, float]],
    ) -> Dict[str, Any]:
        """
        Build comprehensive sources breakdown with ALL tier data
        """
        sources = {}

        if pinecone_match:
            sources["pinecone"] = {
                "match": True,
                "similarity": pinecone_match.similarity,
                "namespace": pinecone_match.namespace,
            }

        if dual_search_results:
            sources["google_search_a"] = {
                "results_count": dual_search_results.search_a_count,
                "pattern": dual_search_results.pattern,
            }
            sources["google_search_b"] = {
                "results_count": dual_search_results.search_b_count,
                "pattern": dual_search_results.pattern,
            }

        # Web Search AI (Tier 1.5) - NEW!
        logger.info(f"üêõ DEBUG: web_brands_a type={type(web_brands_a)}, value={web_brands_a}")
        logger.info(f"üêõ DEBUG: web_brands_b type={type(web_brands_b)}, value={web_brands_b}")
        if web_brands_a or web_brands_b:
            logger.info(f"üêõ DEBUG: Adding web_search_ai to sources!")
            sources["web_search_ai_a"] = {
                "total_results": web_brands_a.get("total_results", 0) if web_brands_a else 0,
                "correct_matches": web_brands_a.get("correct_matches", 0) if web_brands_a else 0,
                "mismatched_count": web_brands_a.get("mismatched_count", 0) if web_brands_a else 0,
                "brands": web_brands_a.get("brands", {}) if web_brands_a else {},
            }
            sources["web_search_ai_b"] = {
                "total_results": web_brands_b.get("total_results", 0) if web_brands_b else 0,
                "correct_matches": web_brands_b.get("correct_matches", 0) if web_brands_b else 0,
                "mismatched_count": web_brands_b.get("mismatched_count", 0) if web_brands_b else 0,
                "brands": web_brands_b.get("brands", {}) if web_brands_b else {},
            }
        else:
            logger.warning(f"üêõ DEBUG: NOT adding web_search_ai (condition false)!")

        if vision_results:
            sources["vision_ai"] = {
                "images_analyzed": vision_results.total_analyzed,
                "products_identified": vision_results.total_products,
                "dominant_brand": vision_results.dominant_brand,
                "brands_detected": vision_results.brand_frequencies,
            }

        # Vision AI filtered results (with product type filtering)
        if vision_brands_a or vision_brands_b:
            sources["vision_ai_search_a"] = {
                "total_images": vision_brands_a.get("total_images", 0) if vision_brands_a else 0,
                "correct_matches": vision_brands_a.get("correct_matches", 0) if vision_brands_a else 0,
                "mismatched_count": vision_brands_a.get("mismatched_count", 0) if vision_brands_a else 0,
                "brands": vision_brands_a.get("brands", {}) if vision_brands_a else {},
            }
            sources["vision_ai_search_b"] = {
                "total_images": vision_brands_b.get("total_images", 0) if vision_brands_b else 0,
                "correct_matches": vision_brands_b.get("correct_matches", 0) if vision_brands_b else 0,
                "mismatched_count": vision_brands_b.get("mismatched_count", 0) if vision_brands_b else 0,
                "brands": vision_brands_b.get("brands", {}) if vision_brands_b else {},
            }

        if kg_results:
            # Build comprehensive KG data with verification details
            kg_entities = {}
            verified_count = 0

            for entity, result in kg_results.items():
                if result:
                    is_verified = result.verified if hasattr(result, 'verified') else False
                    if is_verified:
                        verified_count += 1

                    kg_entities[entity] = {
                        "verified": is_verified,
                        "entity_type": result.entity_type if hasattr(result, 'entity_type') else None,
                        "matches_category": result.matches_user_category if hasattr(result, 'matches_user_category') else False,
                        "category": result.category if hasattr(result, 'category') else None,
                        "description": (result.description[:200] if hasattr(result, 'description') and result.description else "")
                    }
                else:
                    kg_entities[entity] = {
                        "verified": False,
                        "entity_type": None,
                        "matches_category": False,
                        "category": None,
                        "description": ""
                    }

            sources["knowledge_graph"] = {
                "entities": kg_entities,
                "total_entities": len(kg_results),
                "verified_count": verified_count,
            }

        if embedding_similarities:
            sources["embeddings"] = embedding_similarities

        return sources
